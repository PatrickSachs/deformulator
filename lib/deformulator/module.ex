defmodule Deformulator.Module do
  defstruct type: nil, name: nil, info: [], meta: {[], []}, functions: []

  @doc """
  Parses the given beam bytecode into an unoptimized module.

  ## Pameters

    * bytecode - The bytecode

  ## Returns

    * The module structs.
  """
  def parse(bytecode) do
    {type, module, info, meta1, meta2, functions} = bytecode
    %Deformulator.Module{
      type: type,
      name: module,
      info: info,
      meta: {meta1, meta2},
      functions: functions |> Enum.map(fn f -> Deformulator.Function.parse(f) end)
    }
  end

  @doc """
  Optimizes the previously parsed struct. While this step is not mandatory it is highly recommended the greatly reduce the verbosity
  of the generated code. Since the beam VM is a register based machine quite a lot of transformations based on known patterns have
  to be applied afterwards to make the outputted code look like prope functional code insetad of procedural code.
  """
  def optimize(%Deformulator.Module{} = module) do
    module
    |> optimize_strip_module_info
    |> optimize_functions
  end

  defp optimize_functions(%Deformulator.Module{} = module) do
    %Deformulator.Module{ module | functions: Enum.map(module.functions, &Deformulator.Function.optimize/1)}
  end

  ## Removes the module_info functions as it is auto generated by the compiler.
  defp optimize_strip_module_info(%Deformulator.Module{} = module) do
    %Deformulator.Module{ module | functions: Enum.filter(module.functions, fn fun ->
      fun.name !== :module_info
    end)}
  end

  defimpl String.Chars, for: Deformulator.Module do
    def to_string(mod) do
      "defmodule #{mod.name} do
  #{mod.functions |> Enum.join("\n\n")}
end"
    end
  end
end
